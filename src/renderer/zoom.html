<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zoom View - AI Screen Helper</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #1a1a1a;
      color: #00ffff;
      overflow: hidden;
    }

    .header {
      background: rgba(0, 0, 0, 0.9);
      padding: 10px;
      border-bottom: 1px solid #00ffff;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .cell-info {
      font-size: 14px;
    }

    .instructions {
      font-size: 12px;
      opacity: 0.8;
    }

    .zoom-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 60px);
      display: flex;
      flex-direction: column;
    }

    .zoom-canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .zoom-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .fine-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    #gridSquareContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
      pointer-events: none; /* Let grid squares handle their own events */
    }

    .grid-square {
      position: absolute;
      border: 1px solid rgba(255, 255, 0, 0.3);
      background: rgba(255, 255, 0, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
      z-index: 15;
      pointer-events: all;
    }

    .grid-square:hover {
      background: rgba(255, 255, 0, 0.2);
      border-color: rgba(255, 255, 0, 0.8);
      box-shadow: 0 0 8px rgba(255, 255, 0, 0.4);
      transform: scale(1.02);
    }

    .grid-square.clicked {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 1);
      box-shadow: 0 0 12px rgba(255, 0, 0, 0.6);
    }

    .coordinate-display {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #00ffff;
      font-size: 14px;
      font-weight: bold;
    }

    .action-buttons {
      position: absolute;
      bottom: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
    }

    .btn {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .btn:hover {
      background: rgba(0, 255, 255, 0.4);
    }

    .btn.primary {
      background: rgba(0, 255, 255, 0.4);
    }

    .btn.primary:hover {
      background: rgba(0, 255, 255, 0.6);
    }

    .debug-indicator {
      position: absolute;
      top: 80px;
      left: 10px;
      background: rgba(255, 165, 0, 0.9);
      color: #000;
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
      display: none;
      border: 1px solid #ff8c00;
    }

    .crosshair {
      position: absolute;
      pointer-events: none;
      z-index: 20;
    }

    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: #ff0000;
    }

    .crosshair::before {
      width: 100vw;
      height: 1px;
      top: 0;
      left: -50vw;
    }

    .crosshair::after {
      width: 1px;
      height: 100vh;
      top: -50vh;
      left: 0;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="cell-info" id="cellInfo">
      Cell: - | Area: -
    </div>
    <div style="display: flex; align-items: center; gap: 15px;">
      <div class="instructions">
        Click grid squares or type number + Enter to execute click | Escape to close
      </div>
      <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; cursor: pointer;">
        <input type="checkbox" id="debugMode" style="margin: 0;">
        <span>Debug Mode (move only, keep open)</span>
      </label>
    </div>
  </div>

  <div class="zoom-container">
    <div class="zoom-canvas-container">
      <canvas class="zoom-canvas" id="zoomCanvas"></canvas>
      <svg class="fine-grid" id="fineGrid">
        <!-- Fine grid lines will be generated by JavaScript -->
      </svg>
      <div id="gridSquareContainer">
        <!-- Interactive grid squares will be generated here -->
      </div>
      <div class="crosshair" id="crosshair" style="display: none;"></div>
      <div class="debug-indicator" id="debugIndicator">
        üêõ DEBUG MODE: Click squares will only move mouse (no clicking)
      </div>
    </div>

    <div class="coordinate-display" id="coordinateDisplay">
      Mouse: (0, 0) | Screen: (0, 0)
    </div>

    <div class="action-buttons">
      <button class="btn" id="testBtn">Test xdotool</button>
      <button class="btn" id="backBtn">Back to Grid</button>
      <button class="btn" id="closeBtn">Close</button>
      <button class="btn" id="selectBtn">Select Coordinates</button>
      <button class="btn primary" id="clickBtn">Click Here</button>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');

    let currentCellData = null;
    let currentScreenshot = null;
    let currentConfig = null;
    let currentScreenSize = null;
    let currentMousePos = { x: 0, y: 0 };
    let actualMousePos = { x: 0, y: 0 };

    const canvas = document.getElementById('zoomCanvas');
    const ctx = canvas.getContext('2d');
    const fineGrid = document.getElementById('fineGrid');
    const crosshair = document.getElementById('crosshair');

    function setupZoomView(data) {
      currentCellData = data.cellData;
      currentScreenshot = data.screenshot;
      currentConfig = data.config;
      currentScreenSize = data.screenSize;

      // Update cell info display
      document.getElementById('cellInfo').textContent = 
        `Cell: ${currentCellData.number} | Area: ${currentCellData.width}√ó${currentCellData.height}px`;

      drawZoomedArea();
      createFineGrid();
    }

    function drawZoomedArea() {
      if (!currentScreenshot || !currentCellData) return;

      const img = new Image();
      img.onload = function() {
        // Set canvas size
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        // Calculate source rectangle from the original screenshot
        const sourceX = currentCellData.x;
        const sourceY = currentCellData.y;
        const sourceWidth = currentCellData.width;
        const sourceHeight = currentCellData.height;

        // Draw the zoomed portion
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.imageSmoothingEnabled = false; // Pixelated zoom for precision
        ctx.drawImage(
          img,
          sourceX, sourceY, sourceWidth, sourceHeight,
          0, 0, canvas.width, canvas.height
        );
      };
      img.src = currentScreenshot;
    }

    function createFineGrid() {
      if (!currentCellData) return;

      fineGrid.innerHTML = '';
      const gridSquareContainer = document.getElementById('gridSquareContainer');
      gridSquareContainer.innerHTML = '';
      
      const gridSize = 20; // 20x20 pixel grid
      const canvasRect = canvas.getBoundingClientRect();
      
      // Create vertical lines
      for (let i = 0; i <= currentCellData.width; i += gridSize) {
        const x = (i / currentCellData.width) * canvasRect.width;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', x);
        line.setAttribute('y2', canvasRect.height);
        line.setAttribute('stroke', 'rgba(0, 255, 255, 0.3)');
        line.setAttribute('stroke-width', '1');
        fineGrid.appendChild(line);
      }

      // Create horizontal lines
      for (let i = 0; i <= currentCellData.height; i += gridSize) {
        const y = (i / currentCellData.height) * canvasRect.height;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', canvasRect.width);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', 'rgba(0, 255, 255, 0.3)');
        line.setAttribute('stroke-width', '1');
        fineGrid.appendChild(line);
      }

      // Create interactive grid squares and add grid numbers
      const gridCols = Math.ceil(currentCellData.width / gridSize);
      const gridRows = Math.ceil(currentCellData.height / gridSize);
      
      console.log(`üîß GRID: Creating ${gridCols}x${gridRows} interactive squares`);
      
      let gridSquareNumber = 1;
      
      for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
          // Create clickable grid square
          const square = document.createElement('div');
          square.className = 'grid-square';
          
          const squareLeft = (col * gridSize / currentCellData.width) * canvasRect.width;
          const squareTop = (row * gridSize / currentCellData.height) * canvasRect.height;
          const squareWidth = (gridSize / currentCellData.width) * canvasRect.width;
          const squareHeight = (gridSize / currentCellData.height) * canvasRect.height;
          
          square.style.left = squareLeft + 'px';
          square.style.top = squareTop + 'px';
          square.style.width = squareWidth + 'px';
          square.style.height = squareHeight + 'px';
          
          // Calculate center coordinates for this grid square
          const centerX = Math.floor(currentCellData.x + (col + 0.5) * gridSize);
          const centerY = Math.floor(currentCellData.y + (row + 0.5) * gridSize);
          
          square.title = `Square ${gridSquareNumber}: Click to move and click at (${centerX}, ${centerY})`;
          square.setAttribute('data-coords', `${centerX},${centerY}`);
          square.setAttribute('data-grid', `${col},${row}`);
          square.setAttribute('data-number', gridSquareNumber);
          
          // Add visible number inside the square
          const numberSpan = document.createElement('span');
          numberSpan.textContent = gridSquareNumber;
          numberSpan.style.cssText = `
            position: absolute;
            top: 2px;
            left: 2px;
            color: #ffff00;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
          `;
          square.appendChild(numberSpan);
          
          square.addEventListener('click', (event) => {
            console.log(`üéØ GRID SQUARE CLICKED: ${gridSquareNumber} (${col},${row}) -> (${centerX},${centerY})`);
            event.stopPropagation();
            executeClick(centerX, centerY, square);
          });
          
          square.addEventListener('mouseenter', () => {
            console.log(`üñ±Ô∏è HOVER: Grid square ${gridSquareNumber} (${col},${row})`);
          });
          
          gridSquareContainer.appendChild(square);
          
          // Add grid number text to SVG for debugging
          const textX = squareLeft + 5;
          const textY = squareTop + 25; // Lower to avoid overlap with number
          
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', textX);
          text.setAttribute('y', textY);
          text.setAttribute('fill', 'rgba(255, 255, 255, 0.4)');
          text.setAttribute('font-size', '8');
          text.setAttribute('font-family', 'monospace');
          text.textContent = `${gridSquareNumber}`;
          fineGrid.appendChild(text);
          
          gridSquareNumber++;
        }
      }
      
      console.log(`‚úÖ GRID CREATION COMPLETE: ${gridSquareContainer.children.length} interactive squares added`);
      console.log(`üîß CONTAINER: gridSquareContainer positioned and styled`);
    }

    function executeClick(x, y, squareElement) {
      console.log(`üöÄ EXECUTE CLICK FUNCTION CALLED: (${x}, ${y})`);
      
      // Visual feedback (brief)
      squareElement.classList.add('clicked');
      
      const debugMode = document.getElementById('debugMode').checked;
      console.log(`üîß DEBUG MODE: ${debugMode ? 'ENABLED' : 'DISABLED'}`);
      
      if (debugMode) {
        console.log(`üêõ DEBUG: Only moving mouse to (${x}, ${y}) - no click`);
        ipcRenderer.send('debug-move-mouse', {
          x: x,
          y: y,
          cellNumber: currentCellData.number,
          debugMode: true
        });
        // Keep zoom window open in debug mode for testing
        setTimeout(() => {
          squareElement.classList.remove('clicked');
        }, 500);
      } else {
        console.log(`üñ±Ô∏è EXECUTING: Move and click at (${x}, ${y}) - preparing to close zoom window`);
        
        // Send message to hide overlay immediately
        console.log(`üì§ SENDING: hide-overlay-and-execute message`);
        ipcRenderer.send('hide-overlay-and-execute', {
          x: x,
          y: y,
          cellNumber: currentCellData.number
        });
        console.log(`üì§ MESSAGE SENT: hide-overlay-and-execute`);
        
        // Close zoom window immediately to avoid interference
        console.log(`üîí CLOSING: Zoom window`);
        window.close();
      }
    }

    // Mouse tracking
    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      const canvasX = event.clientX - rect.left;
      const canvasY = event.clientY - rect.top;

      // Calculate relative position within the cell
      const relativeX = (canvasX / rect.width) * currentCellData.width;
      const relativeY = (canvasY / rect.height) * currentCellData.height;

      // Calculate actual screen coordinates
      actualMousePos.x = Math.floor(currentCellData.x + relativeX);
      actualMousePos.y = Math.floor(currentCellData.y + relativeY);

      currentMousePos.x = Math.floor(canvasX);
      currentMousePos.y = Math.floor(canvasY);

      // Update coordinate display
      document.getElementById('coordinateDisplay').textContent = 
        `Mouse: (${currentMousePos.x}, ${currentMousePos.y}) | Screen: (${actualMousePos.x}, ${actualMousePos.y})`;

      // Update crosshair
      crosshair.style.display = 'block';
      crosshair.style.left = canvasX + 'px';
      crosshair.style.top = canvasY + 'px';
    });

    canvas.addEventListener('mouseleave', () => {
      crosshair.style.display = 'none';
    });

    // Canvas click completely disabled - using grid squares instead
    // Keep mousemove for crosshair, but disable clicks
    canvas.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('‚ö†Ô∏è CANVAS CLICK BLOCKED: Use grid squares instead');
      return false;
    });
    console.log('üîß SETUP: Canvas clicks blocked, grid squares will handle clicks');

    function selectCoordinates(executeClick = false) {
      const coordinateData = {
        x: actualMousePos.x,
        y: actualMousePos.y,
        cellNumber: currentCellData.number,
        executeClick: executeClick
      };

      ipcRenderer.send('coordinate-selected', coordinateData);
      
      if (!executeClick) {
        // Just log the coordinates
        console.log(`Selected coordinates: (${coordinateData.x}, ${coordinateData.y})`);
      }
    }

    function debugClickCoordinates() {
      const coordinateData = {
        x: actualMousePos.x,
        y: actualMousePos.y,
        cellNumber: currentCellData.number,
        executeClick: false, // Don't click, just move for debugging
        debugMode: true
      };

      console.log(`üêõ DEBUG MODE: Moving mouse to (${coordinateData.x}, ${coordinateData.y})`);
      ipcRenderer.send('debug-move-mouse', coordinateData);
    }

    // Variables for keyboard input
    let zoomKeyboardInput = '';
    let zoomKeyboardTimeout = null;

    // Helper functions for keyboard input in zoom window
    function showZoomKeyboardInput(input) {
      let inputDisplay = document.getElementById('zoom-keyboard-input-display');
      if (!inputDisplay) {
        inputDisplay = document.createElement('div');
        inputDisplay.id = 'zoom-keyboard-input-display';
        inputDisplay.style.cssText = `
          position: fixed;
          top: 10px;
          right: 10px;
          background: rgba(0, 0, 0, 0.9);
          color: #00ff00;
          padding: 10px 15px;
          border-radius: 5px;
          font-size: 18px;
          font-weight: bold;
          font-family: 'Courier New', monospace;
          z-index: 10000;
          border: 2px solid #00ff00;
          box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        `;
        document.body.appendChild(inputDisplay);
      }
      inputDisplay.textContent = `Square: ${input}`;
      inputDisplay.style.display = 'block';
    }

    function hideZoomKeyboardInput() {
      const inputDisplay = document.getElementById('zoom-keyboard-input-display');
      if (inputDisplay) {
        inputDisplay.style.display = 'none';
      }
    }

    function selectGridSquareByNumber(squareNumber) {
      const squares = document.querySelectorAll('.grid-square');
      const targetSquare = Array.from(squares).find(square => {
        return parseInt(square.getAttribute('data-number')) === squareNumber;
      });

      if (targetSquare) {
        // Visual feedback
        targetSquare.style.background = 'rgba(0, 255, 0, 0.8)';
        targetSquare.style.borderColor = '#00ff00';
        
        // Get coordinates and execute click
        const coords = targetSquare.getAttribute('data-coords').split(',');
        const centerX = parseInt(coords[0]);
        const centerY = parseInt(coords[1]);
        
        console.log(`‚å®Ô∏è KEYBOARD: Selected grid square ${squareNumber} -> (${centerX}, ${centerY})`);
        
        setTimeout(() => {
          executeClick(centerX, centerY, targetSquare);
        }, 200); // Brief delay to show visual feedback
      }
    }

    // Keyboard event handler for zoom window
    document.addEventListener('keydown', (event) => {
      // Handle number input for grid square selection
      if (event.key >= '0' && event.key <= '9') {
        zoomKeyboardInput += event.key;
        
        // Clear existing timeout
        if (zoomKeyboardTimeout) {
          clearTimeout(zoomKeyboardTimeout);
        }
        
        // Set timeout to clear input after 2 seconds
        zoomKeyboardTimeout = setTimeout(() => {
          zoomKeyboardInput = '';
          hideZoomKeyboardInput();
        }, 2000);
        
        showZoomKeyboardInput(zoomKeyboardInput);
        event.preventDefault();
        return;
      }

      // Handle Enter key to execute selection
      if (event.key === 'Enter' && zoomKeyboardInput.length > 0) {
        const squareNumber = parseInt(zoomKeyboardInput);
        const totalSquares = document.querySelectorAll('.grid-square').length;
        
        if (squareNumber >= 1 && squareNumber <= totalSquares) {
          selectGridSquareByNumber(squareNumber);
        }
        
        zoomKeyboardInput = '';
        hideZoomKeyboardInput();
        event.preventDefault();
        return;
      }

      // Handle Backspace to remove last digit
      if (event.key === 'Backspace' && zoomKeyboardInput.length > 0) {
        zoomKeyboardInput = zoomKeyboardInput.slice(0, -1);
        if (zoomKeyboardInput.length > 0) {
          showZoomKeyboardInput(zoomKeyboardInput);
        } else {
          hideZoomKeyboardInput();
        }
        event.preventDefault();
        return;
      }

      // Handle Escape to close window
      if (event.key === 'Escape') {
        zoomKeyboardInput = '';
        hideZoomKeyboardInput();
        window.close();
        event.preventDefault();
        return;
      }
    });

    // Button handlers
    document.getElementById('testBtn').addEventListener('click', () => {
      console.log('üß™ Testing xdotool functionality...');
      ipcRenderer.send('test-xdotool');
    });

    document.getElementById('backBtn').addEventListener('click', () => {
      ipcRenderer.send('show-overlay-again');
      window.close();
    });

    document.getElementById('closeBtn').addEventListener('click', () => {
      window.close();
    });

    document.getElementById('selectBtn').addEventListener('click', () => {
      selectCoordinates(false);
    });

    document.getElementById('clickBtn').addEventListener('click', () => {
      selectCoordinates(true);
      window.close();
    });

    // Handle global enter command (Ctrl+Shift+M backup)
    ipcRenderer.on('global-enter-command', () => {
      console.log('üåê ZOOM GLOBAL ENTER: Received global enter command');
      if (zoomKeyboardInput.length > 0) {
        console.log(`üåê ZOOM GLOBAL ENTER: Executing selection for input: ${zoomKeyboardInput}`);
        const squareNumber = parseInt(zoomKeyboardInput);
        const totalSquares = document.querySelectorAll('.grid-square').length;
        
        if (squareNumber >= 1 && squareNumber <= totalSquares) {
          selectGridSquareByNumber(squareNumber);
        }
        
        zoomKeyboardInput = '';
        hideZoomKeyboardInput();
      } else {
        console.log('üåê ZOOM GLOBAL ENTER: No keyboard input to execute');
      }
    });

    // Handle zoom data from main process
    ipcRenderer.on('show-zoom', (event, data) => {
      setupZoomView(data);
    });

    // Handle debug mode checkbox
    document.getElementById('debugMode').addEventListener('change', (event) => {
      const debugIndicator = document.getElementById('debugIndicator');
      if (event.target.checked) {
        debugIndicator.style.display = 'block';
        console.log('üêõ DEBUG MODE ENABLED: Clicks will execute xdotool mousemove commands');
      } else {
        debugIndicator.style.display = 'none';
        console.log('üêõ DEBUG MODE DISABLED: Normal coordinate selection mode');
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      setTimeout(() => {
        drawZoomedArea();
        createFineGrid();
      }, 100);
    });
  </script>
</body>
</html>