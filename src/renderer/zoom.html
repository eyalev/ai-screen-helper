<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Zoom View - AI Screen Helper</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #1a1a1a;
      color: #00ffff;
      overflow: hidden;
    }

    .header {
      background: rgba(0, 0, 0, 0.9);
      padding: 10px;
      border-bottom: 1px solid #00ffff;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .cell-info {
      font-size: 14px;
    }

    .instructions {
      font-size: 12px;
      opacity: 0.8;
    }

    .zoom-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 60px);
      display: flex;
      flex-direction: column;
    }

    .zoom-canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .zoom-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }

    .fine-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .coordinate-display {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #00ffff;
      font-size: 14px;
      font-weight: bold;
    }

    .action-buttons {
      position: absolute;
      bottom: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
    }

    .btn {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .btn:hover {
      background: rgba(0, 255, 255, 0.4);
    }

    .btn.primary {
      background: rgba(0, 255, 255, 0.4);
    }

    .btn.primary:hover {
      background: rgba(0, 255, 255, 0.6);
    }

    .crosshair {
      position: absolute;
      pointer-events: none;
      z-index: 20;
    }

    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: #ff0000;
    }

    .crosshair::before {
      width: 100vw;
      height: 1px;
      top: 0;
      left: -50vw;
    }

    .crosshair::after {
      width: 1px;
      height: 100vh;
      top: -50vh;
      left: 0;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="cell-info" id="cellInfo">
      Cell: - | Area: -
    </div>
    <div class="instructions">
      Click on the zoomed area to select precise coordinates
    </div>
  </div>

  <div class="zoom-container">
    <div class="zoom-canvas-container">
      <canvas class="zoom-canvas" id="zoomCanvas"></canvas>
      <svg class="fine-grid" id="fineGrid">
        <!-- Fine grid lines will be generated by JavaScript -->
      </svg>
      <div class="crosshair" id="crosshair" style="display: none;"></div>
    </div>

    <div class="coordinate-display" id="coordinateDisplay">
      Mouse: (0, 0) | Screen: (0, 0)
    </div>

    <div class="action-buttons">
      <button class="btn" id="backBtn">Back to Grid</button>
      <button class="btn" id="closeBtn">Close</button>
      <button class="btn" id="selectBtn">Select Coordinates</button>
      <button class="btn primary" id="clickBtn">Click Here</button>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');

    let currentCellData = null;
    let currentScreenshot = null;
    let currentConfig = null;
    let currentScreenSize = null;
    let currentMousePos = { x: 0, y: 0 };
    let actualMousePos = { x: 0, y: 0 };

    const canvas = document.getElementById('zoomCanvas');
    const ctx = canvas.getContext('2d');
    const fineGrid = document.getElementById('fineGrid');
    const crosshair = document.getElementById('crosshair');

    function setupZoomView(data) {
      currentCellData = data.cellData;
      currentScreenshot = data.screenshot;
      currentConfig = data.config;
      currentScreenSize = data.screenSize;

      // Update cell info display
      document.getElementById('cellInfo').textContent = 
        `Cell: ${currentCellData.number} | Area: ${currentCellData.width}Ã—${currentCellData.height}px`;

      drawZoomedArea();
      createFineGrid();
    }

    function drawZoomedArea() {
      if (!currentScreenshot || !currentCellData) return;

      const img = new Image();
      img.onload = function() {
        // Set canvas size
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        // Calculate source rectangle from the original screenshot
        const sourceX = currentCellData.x;
        const sourceY = currentCellData.y;
        const sourceWidth = currentCellData.width;
        const sourceHeight = currentCellData.height;

        // Draw the zoomed portion
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.imageSmoothingEnabled = false; // Pixelated zoom for precision
        ctx.drawImage(
          img,
          sourceX, sourceY, sourceWidth, sourceHeight,
          0, 0, canvas.width, canvas.height
        );
      };
      img.src = currentScreenshot;
    }

    function createFineGrid() {
      if (!currentCellData) return;

      fineGrid.innerHTML = '';
      
      const gridSize = 20; // 20x20 pixel grid
      const canvasRect = canvas.getBoundingClientRect();
      
      // Create vertical lines
      for (let i = 0; i <= currentCellData.width; i += gridSize) {
        const x = (i / currentCellData.width) * canvasRect.width;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x);
        line.setAttribute('y1', 0);
        line.setAttribute('x2', x);
        line.setAttribute('y2', canvasRect.height);
        line.setAttribute('stroke', 'rgba(0, 255, 255, 0.3)');
        line.setAttribute('stroke-width', '1');
        fineGrid.appendChild(line);
      }

      // Create horizontal lines
      for (let i = 0; i <= currentCellData.height; i += gridSize) {
        const y = (i / currentCellData.height) * canvasRect.height;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', y);
        line.setAttribute('x2', canvasRect.width);
        line.setAttribute('y2', y);
        line.setAttribute('stroke', 'rgba(0, 255, 255, 0.3)');
        line.setAttribute('stroke-width', '1');
        fineGrid.appendChild(line);
      }

      // Add grid numbers
      const gridCols = Math.ceil(currentCellData.width / gridSize);
      const gridRows = Math.ceil(currentCellData.height / gridSize);
      
      for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
          const x = (col * gridSize / currentCellData.width) * canvasRect.width + 5;
          const y = (row * gridSize / currentCellData.height) * canvasRect.height + 15;
          
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', x);
          text.setAttribute('y', y);
          text.setAttribute('fill', 'rgba(255, 255, 255, 0.6)');
          text.setAttribute('font-size', '10');
          text.setAttribute('font-family', 'monospace');
          text.textContent = `${col},${row}`;
          fineGrid.appendChild(text);
        }
      }
    }

    // Mouse tracking
    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      const canvasX = event.clientX - rect.left;
      const canvasY = event.clientY - rect.top;

      // Calculate relative position within the cell
      const relativeX = (canvasX / rect.width) * currentCellData.width;
      const relativeY = (canvasY / rect.height) * currentCellData.height;

      // Calculate actual screen coordinates
      actualMousePos.x = Math.floor(currentCellData.x + relativeX);
      actualMousePos.y = Math.floor(currentCellData.y + relativeY);

      currentMousePos.x = Math.floor(canvasX);
      currentMousePos.y = Math.floor(canvasY);

      // Update coordinate display
      document.getElementById('coordinateDisplay').textContent = 
        `Mouse: (${currentMousePos.x}, ${currentMousePos.y}) | Screen: (${actualMousePos.x}, ${actualMousePos.y})`;

      // Update crosshair
      crosshair.style.display = 'block';
      crosshair.style.left = canvasX + 'px';
      crosshair.style.top = canvasY + 'px';
    });

    canvas.addEventListener('mouseleave', () => {
      crosshair.style.display = 'none';
    });

    // Click to select coordinates
    canvas.addEventListener('click', () => {
      selectCoordinates();
    });

    function selectCoordinates(executeClick = false) {
      const coordinateData = {
        x: actualMousePos.x,
        y: actualMousePos.y,
        cellNumber: currentCellData.number,
        executeClick: executeClick
      };

      ipcRenderer.send('coordinate-selected', coordinateData);
      
      if (!executeClick) {
        // Just log the coordinates
        console.log(`Selected coordinates: (${coordinateData.x}, ${coordinateData.y})`);
      }
    }

    // Button handlers
    document.getElementById('backBtn').addEventListener('click', () => {
      ipcRenderer.send('show-overlay-again');
      window.close();
    });

    document.getElementById('closeBtn').addEventListener('click', () => {
      window.close();
    });

    document.getElementById('selectBtn').addEventListener('click', () => {
      selectCoordinates(false);
    });

    document.getElementById('clickBtn').addEventListener('click', () => {
      selectCoordinates(true);
      window.close();
    });

    // Handle zoom data from main process
    ipcRenderer.on('show-zoom', (event, data) => {
      setupZoomView(data);
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      setTimeout(() => {
        drawZoomedArea();
        createFineGrid();
      }, 100);
    });
  </script>
</body>
</html>